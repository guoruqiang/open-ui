import asyncio
import datetime
import logging
import os
import time
from collections import defaultdict

import aiohttp
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from open_webui.apps.filter.wordsSearch import wordsSearch
from open_webui.apps.socket.utils import RedisDict
from open_webui.apps.webui.routers.chats import request_share_chat_by_id, request_get_chat_by_id
from open_webui.config import (
    AppConfig,
    ENABLE_MESSAGE_FILTER,
    CHAT_FILTER_WORDS_FILE,
    CHAT_FILTER_WORDS,
    ENABLE_REPLACE_FILTER_WORDS,
    REPLACE_FILTER_WORDS,
    ENABLE_WECHAT_NOTICE,
    ENABLE_DAILY_USAGES_NOTICE,
    SEND_FILTER_MESSAGE_TYPE,
    WECHAT_NOTICE_SUFFIX,
    WECHAT_APP_SECRET,
)
from open_webui.env import DATA_DIR, SRC_LOG_LEVELS, WEBUI_URL, WEBUI_NAME, WEBSOCKET_REDIS_URL, WEBSOCKET_MANAGER
from open_webui.utils.utils import (
    get_admin_user,
)
from pydantic import BaseModel

log = logging.getLogger(__name__)
log.setLevel(SRC_LOG_LEVELS["FILTER"])

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
scheduler = AsyncIOScheduler()

app.state.config = AppConfig()

app.state.config.ENABLE_MESSAGE_FILTER = ENABLE_MESSAGE_FILTER
app.state.config.CHAT_FILTER_WORDS_FILE = CHAT_FILTER_WORDS_FILE
app.state.config.CHAT_FILTER_WORDS = CHAT_FILTER_WORDS
app.state.config.ENABLE_REPLACE_FILTER_WORDS = ENABLE_REPLACE_FILTER_WORDS
app.state.config.REPLACE_FILTER_WORDS = REPLACE_FILTER_WORDS
app.state.config.ENABLE_WECHAT_NOTICE = ENABLE_WECHAT_NOTICE
app.state.config.WECHAT_APP_SECRET = WECHAT_APP_SECRET
app.state.config.ENABLE_DAILY_USAGES_NOTICE = ENABLE_DAILY_USAGES_NOTICE
app.state.config.SEND_FILTER_MESSAGE_TYPE = SEND_FILTER_MESSAGE_TYPE
app.state.config.WECHAT_NOTICE_SUFFIX = WECHAT_NOTICE_SUFFIX

file_path = os.path.join(DATA_DIR, app.state.config.CHAT_FILTER_WORDS_FILE)
user_usage = defaultdict(lambda: defaultdict(int))
redis_client = None
if WEBSOCKET_REDIS_URL and WEBSOCKET_MANAGER == "redis":
    user_usage = RedisDict(
        "open-webui:user_usage", redis_url=WEBSOCKET_REDIS_URL
    )
usage_lock = asyncio.Lock()
search = None


async def reset_usage():
    global user_usage
    if isinstance(user_usage, RedisDict):
        user_usage.clear()
    else:
        user_usage = defaultdict(lambda: defaultdict(int))


async def new_number_sign_up_notice(name, role, email):
    data = await notice_newnumber_signup_to_wechatapp(name, role, email)
    await send_message_to_wechatapp(data)


async def daily_send_usage():
    datas = await prepare_usage_to_wechatapp()
    for data in datas:
        await send_message_to_wechatapp(data)


async def prepare_usage_to_wechatapp():
    if app.state.config.SEND_FILTER_MESSAGE_TYPE.lower() == "markdown":
        contents = await init_markdown_usages()
        msg_type = "markdown"
    else:
        contents = await init_usages()
        msg_type = "text"

    datas = [
        {
            "msgtype": msg_type,
            msg_type: {
                "content": content,
                "mentioned_list": [] if msg_type == "markdown" else None,
            }
        }
        for content in contents
    ]

    return datas


async def notice_newnumber_signup_to_wechatapp(name, role, email):
    data = {
        "msgtype": "text",
        "text": {
            "content": f"‚ú®‚ú®‚ú®{WEBUI_NAME}"
                       f"\n\nü§ñÁî®Êà∑Ôºö{name}"
                       f"\n\nüîçËßíËâ≤Ôºö{role}"
                       f"\n\nüìÆÈÇÆÁÆ±Ôºö{email}"
                       f"\n\nüåüÁî®Êà∑Â∑≤Ê≥®ÂÜåÊàêÂäüÔºåËØ∑Á°ÆËÆ§ÊòØÂê¶Ê≠£ÂºèÈÄöËøáÔºÅ"
                       f"\n\n{app.state.config.WECHAT_NOTICE_SUFFIX}"
        }
    }
    return data


async def prepare_data_to_wechatapp(share_id, user, replyType: str, content: str):
    if replyType.lower() == "markdown":
        data = {
            "msgtype": "news",
            "news": {
                "articles": [
                    {
                        "title": f"üö®{user.name}ÊèêÈóÆÊïèÊÑüÊ∂àÊÅØÔºÅ",
                        "description": "üí¢üí¢üí¢‰∏∫‰∫ÜAPIÁöÑÊ≠£Â∏∏ËøêË°åÔºåËµ∂Á¥ßÁÇπÂºÄÁúãÁúãÂêßÔºÅ",
                        "url": f"{WEBUI_URL}/s/{share_id}",
                        "picurl": f"{WEBUI_URL}/static/favicon.png"
                    }
                ]
            }
        }
    else:
        data = {
            "msgtype": "text",
            "text": {
                "content": f"üö®üö®üö® Ë≠¶Âëä"
                           f"\n\n{user.name}ÊèêÈóÆÊïèÊÑüÊ∂àÊÅØÔºÅ"
                           f"\n\nüòÖ {content}"
                           f"\n\nüîó {WEBUI_URL}/s/{share_id}"
                           f"\n\nüí¢ ‰∏∫‰∫ÜAPIÁöÑÊ≠£Â∏∏ËøêË°åÔºåËµ∂Á¥ßÁÇπÂºÄÁúãÁúãÂêßÔºÅ"
                           f"\n\n{app.state.config.WECHAT_NOTICE_SUFFIX}"
            }
        }
    return data


async def send_message_to_wechatapp(data):
    url = f"https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key={app.state.config.WECHAT_APP_SECRET}"
    log.info(f"Send message to WeChat app: {url}")
    headers = {'Content-type': 'application/json'}
    log.info(f"Send message to WeChat app: {data}")

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=data, headers=headers) as response:
                response.raise_for_status()  # Â¶ÇÊûúÁä∂ÊÄÅÁ†Å‰∏çÊòØ200-299Ôºå‰ºöÂºïÂèëÂºÇÂ∏∏
                response_text = await response.text()
                log.info(f"POST ËØ∑Ê±ÇÊàêÂäü: {url}, Áä∂ÊÄÅÁ†Å: {response.status}, ÂìçÂ∫î: {response_text}")
                return response_text
    except aiohttp.ClientError as e:
        log.error(f"POST ËØ∑Ê±ÇÂ§±Ë¥•: {url}, ÈîôËØØ: {str(e)}")


async def init_file():
    if app.state.config.CHAT_FILTER_WORDS_FILE:
        if os.path.exists(DATA_DIR):
            if os.path.isfile(file_path):
                with open(file_path, "r", encoding="utf-8") as file:
                    lines = file.readlines()
                    unique_lines = set(line.strip() for line in lines)
                    joined_text = ",".join(unique_lines)
                    app.state.config.CHAT_FILTER_WORDS = joined_text if joined_text else ""
            else:
                await write_words_to_file()


async def write_words_to_file():
    new_bad_words = set(
        word.strip() for word in app.state.config.CHAT_FILTER_WORDS.split(",")
    )
    app.state.config.CHAT_FILTER_WORDS = ",".join(sorted(new_bad_words))
    if app.state.config.CHAT_FILTER_WORDS:
        with open(file_path, "w", encoding="utf-8") as file:
            file.write("\n".join(sorted(new_bad_words)) + "\n")
    else:
        with open(file_path, "w", encoding="utf-8") as file:
            file.write("")
    log.info(f"Create a new bad words file: {file_path}")


async def app_start():
    global search

    log.info("Initializing files...")
    await init_file()

    if app.state.config.ENABLE_WECHAT_NOTICE:
        log.info("WeChat notice enabled.")
        scheduler.add_job(reset_usage, 'cron', day_of_week='sun', hour=0, minute=0, id='reset_usage')
        log.info("Added reset_usage job.")
        if app.state.config.ENABLE_DAILY_USAGES_NOTICE:
            log.info("Daily usages notice enabled.")
            scheduler.add_job(daily_send_usage, 'cron', hour=23, minute=30, id='daily_send_usage')
            log.info("Added daily_send_usage job.")
        scheduler.start()
        log.info("Scheduler started.")

    search = None
    if app.state.config.ENABLE_MESSAGE_FILTER and app.state.config.CHAT_FILTER_WORDS:
        log.info("Message filter enabled with keywords.")
        search = wordsSearch()
        search.SetKeywords(app.state.config.CHAT_FILTER_WORDS.split(","))
        log.info("Keywords set for message filter.")


class FILTERConfigForm(BaseModel):
    ENABLE_MESSAGE_FILTER: bool
    CHAT_FILTER_WORDS: str
    CHAT_FILTER_WORDS_FILE: str
    ENABLE_REPLACE_FILTER_WORDS: bool
    REPLACE_FILTER_WORDS: str
    ENABLE_WECHAT_NOTICE: bool
    WECHAT_APP_SECRET: str
    ENABLE_DAILY_USAGES_NOTICE: bool
    SEND_FILTER_MESSAGE_TYPE: str
    WECHAT_NOTICE_SUFFIX: str


@app.get("/config")
async def get_filter_config(user=Depends(get_admin_user)):
    return {
        "ENABLE_MESSAGE_FILTER": app.state.config.ENABLE_MESSAGE_FILTER,
        "CHAT_FILTER_WORDS": app.state.config.CHAT_FILTER_WORDS,
        "CHAT_FILTER_WORDS_FILE": app.state.config.CHAT_FILTER_WORDS_FILE,
        "ENABLE_REPLACE_FILTER_WORDS": app.state.config.ENABLE_REPLACE_FILTER_WORDS,
        "REPLACE_FILTER_WORDS": app.state.config.REPLACE_FILTER_WORDS,
        "ENABLE_WECHAT_NOTICE": app.state.config.ENABLE_WECHAT_NOTICE,
        "WECHAT_APP_SECRET": app.state.config.WECHAT_APP_SECRET,
        "ENABLE_DAILY_USAGES_NOTICE": app.state.config.ENABLE_DAILY_USAGES_NOTICE,
        "SEND_FILTER_MESSAGE_TYPE": app.state.config.SEND_FILTER_MESSAGE_TYPE,
        "WECHAT_NOTICE_SUFFIX": app.state.config.WECHAT_NOTICE_SUFFIX,
    }


@app.post("/config/update")
async def update_filter_config(
        form_data: FILTERConfigForm, user=Depends(get_admin_user)
):
    global search
    global file_path

    app.state.config.ENABLE_MESSAGE_FILTER = form_data.ENABLE_MESSAGE_FILTER
    app.state.config.CHAT_FILTER_WORDS_FILE = form_data.CHAT_FILTER_WORDS_FILE
    app.state.config.ENABLE_REPLACE_FILTER_WORDS = form_data.ENABLE_REPLACE_FILTER_WORDS
    app.state.config.REPLACE_FILTER_WORDS = form_data.REPLACE_FILTER_WORDS
    app.state.config.ENABLE_WECHAT_NOTICE = form_data.ENABLE_WECHAT_NOTICE
    app.state.config.WECHAT_APP_SECRET = form_data.WECHAT_APP_SECRET
    app.state.config.ENABLE_DAILY_USAGES_NOTICE = form_data.ENABLE_DAILY_USAGES_NOTICE
    app.state.config.SEND_FILTER_MESSAGE_TYPE = form_data.SEND_FILTER_MESSAGE_TYPE
    app.state.config.WECHAT_NOTICE_SUFFIX = form_data.WECHAT_NOTICE_SUFFIX

    request_file_path = os.path.join(DATA_DIR, app.state.config.CHAT_FILTER_WORDS_FILE)

    if request_file_path != file_path:
        app.state.config.CHAT_FILTER_WORDS = form_data.CHAT_FILTER_WORDS
        file_path = request_file_path
        await init_file()

    else:
        if app.state.config.CHAT_FILTER_WORDS != form_data.CHAT_FILTER_WORDS:
            app.state.config.CHAT_FILTER_WORDS = form_data.CHAT_FILTER_WORDS
            await write_words_to_file()

    search = wordsSearch()
    search.SetKeywords(app.state.config.CHAT_FILTER_WORDS.split(","))

    if not app.state.config.ENABLE_DAILY_USAGES_NOTICE and scheduler.get_job('daily_send_usage'):
        scheduler.remove_job('daily_send_usage')
        if not scheduler.get_job('daily_send_usage'):
            log.info("Remove daily_send_usage job.")
    elif app.state.config.ENABLE_DAILY_USAGES_NOTICE and not scheduler.get_job('daily_send_usage'):
        scheduler.add_job(daily_send_usage, 'cron', hour=23, minute=30, id='daily_send_usage')
        if scheduler.get_job('daily_send_usage'):
            log.info("Add daily_send_usage job.")

    return {
        "ENABLE_MESSAGE_FILTER": app.state.config.ENABLE_MESSAGE_FILTER,
        "CHAT_FILTER_WORDS": app.state.config.CHAT_FILTER_WORDS,
        "CHAT_FILTER_WORDS_FILE": app.state.config.CHAT_FILTER_WORDS_FILE,
        "ENABLE_REPLACE_FILTER_WORDS": app.state.config.ENABLE_REPLACE_FILTER_WORDS,
        "REPLACE_FILTER_WORDS": app.state.config.REPLACE_FILTER_WORDS,
        "ENABLE_WECHAT_NOTICE": app.state.config.ENABLE_WECHAT_NOTICE,
        "WECHAT_APP_SECRET": app.state.config.WECHAT_APP_SECRET,
        "ENABLE_DAILY_USAGES_NOTICE": app.state.config.ENABLE_DAILY_USAGES_NOTICE,
        "SEND_FILTER_MESSAGE_TYPE": app.state.config.SEND_FILTER_MESSAGE_TYPE,
        "WECHAT_NOTICE_SUFFIX": app.state.config.WECHAT_NOTICE_SUFFIX,
    }


async def init_markdown_usages():
    usage_strings = []
    now = datetime.datetime.now()
    formatted_now = now.strftime("%YÂπ¥%mÊúà%dÊó• %HÊó∂%MÂàÜ")
    reply_text = f"### üìÖ **{formatted_now}**\n\n### ü§ñ **{WEBUI_NAME} ‰ΩøÁî®ÊÉÖÂÜµÂ¶Ç‰∏ãÔºö**"
    usage_strings.append(reply_text)

    if isinstance(user_usage, RedisDict):
        all_users = user_usage.keys()
        users_data = ((user_name, user_usage.get(user_name, {})) for user_name in all_users)
    else:
        users_data = user_usage.items()

    for user_name, models in users_data:
        if not models:
            continue
        model_usage_list = [f"{model}: {count}" for model, count in sorted(models.items())]
        usage_string = f"‚≠êÁî®Êà∑ {user_name} \n" + "\n".join(model_usage_list)
        usage_strings.append(usage_string)

    usage_strings.append(f"{app.state.config.WECHAT_NOTICE_SUFFIX}")
    return usage_strings


async def init_usages():
    usage_strings = []
    now = datetime.datetime.now()
    formatted_now = now.strftime("%YÂπ¥%mÊúà%dÊó• %HÊó∂%MÂàÜ")
    reply_text = f"üìÖ {formatted_now}\n\nü§ñ {WEBUI_NAME}‰ΩøÁî®Â¶Ç‰∏ãÔºö"
    usage_strings.append(reply_text)

    if isinstance(user_usage, RedisDict):
        all_users = user_usage.keys()
        users_data = ((user_name, user_usage.get(user_name, {})) for user_name in all_users)
    else:
        users_data = user_usage.items()

    for user_name, models in users_data:
        if not models:
            continue
        model_usage_list = [f"{model}: {count}" for model, count in sorted(models.items())]
        usage_string = f"‚≠êÁî®Êà∑ {user_name} \n" + "\n".join(model_usage_list)
        usage_strings.append(usage_string)

    usage_strings.append(f"{app.state.config.WECHAT_NOTICE_SUFFIX}")
    return usage_strings


async def process_user_usage(model, user):
    global user_usage
    model_name = model.get("name", "")
    user_name = user.name
    try:
        # Ëé∑ÂèñÁî®Êà∑ÁöÑ‰ΩøÁî®Êï∞ÊçÆÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÂàùÂßãÂåñ
        async with usage_lock:
            if isinstance(user_usage, RedisDict):
                user_data = user_usage.get(user_name, {})
                user_data[model_name] = user_data.get(model_name, 0) + 1
                user_usage[user_name] = user_data
            else:
                user_usage[user_name][model_name] += 1
    except Exception as e:
        log.error(f"Â§ÑÁêÜÁî®Êà∑‰ΩøÁî®Êï∞ÊçÆÊó∂ÂèëÁîüÈîôËØØ: {e}")


@app.post("/usages")
async def get_usages(
        user=Depends(get_admin_user)
):
    if user.role != "admin":
        raise HTTPException(status_code=401, detail="Permission denied.")

    return {"data": await init_usages()}


async def content_filter_message(payload: dict, content: str, user):
    if content:
        chat_id = payload.get("metadata", {}).get("chat_id", None)
        if chat_id:
            log.info("chat_id: " + chat_id)
        start_time = time.time()
        filter_condition = search.FindFirst(content)
        if filter_condition:
            filter_word = filter_condition["Keyword"]
            log.info(
                "The time taken to check the filter words: %.6fs",
                time.time() - start_time,
            )

            if chat_id and app.state.config.ENABLE_WECHAT_NOTICE:
                try:
                    if chat_id != "local":
                        await request_share_chat_by_id(chat_id, user)
                        share_response = await request_get_chat_by_id(chat_id, user)
                        share_id = getattr(share_response, 'share_id', None)

                        if share_id:
                            log.info(f"Share ID: {share_id}")
                            data = await prepare_data_to_wechatapp(
                                share_id, user,
                                app.state.config.SEND_FILTER_MESSAGE_TYPE, content
                            )
                            await send_message_to_wechatapp(data)
                    else:
                        data = {
                            "msgtype": "text",
                            "text": {
                                "content": f"üö®üö®üö® Ë≠¶Âëä"
                                           f"\n\n{user.name}ÊèêÈóÆÊïèÊÑüÊ∂àÊÅØÔºÅ"
                                           f"\n\nüòÖ {content[:100]}"
                                           f"\n\nüí¢ ‰∏∫‰∫ÜAPIÁöÑÊ≠£Â∏∏ËøêË°åÔºåËµ∂Á¥ßÁÇπÂºÄÁúãÁúãÂêßÔºÅ"
                                           f"\n\n{app.state.config.WECHAT_NOTICE_SUFFIX}"
                            }
                        }
                        await send_message_to_wechatapp(data)
                except Exception as e:
                    log.error(f"ÂèëÈÄÅÊ∂àÊÅØÂà∞ÂæÆ‰ø°Â∫îÁî®Â§±Ë¥•: {e}")

            if not app.state.config.ENABLE_REPLACE_FILTER_WORDS:
                detail_message = (
                    f"Yubb Chat: ÊÇ®ÁöÑÊ∂àÊÅØÂåÖÂê´ÊïèÊÑüËØçËØ≠Ôºà`{filter_word}`ÔºâÊó†Ê≥ïÂèëÈÄÅ„ÄÇËØ∑ÂàõÂª∫Êñ∞ËØùÈ¢òÂπ∂ÈáçËØï„ÄÇ"
                )
                raise HTTPException(
                    status_code=503, detail=detail_message
                )
            else:
                filter_text = search.Replace(content, app.state.config.REPLACE_FILTER_WORDS)
                return filter_text
    return content


async def filter_message(payload: dict, user):
    messages = payload.get("messages", None)

    if app.state.config.ENABLE_MESSAGE_FILTER and search:
        if messages:
            for message in reversed(messages):
                if message.get("role") == "user":
                    content = message.get("content")
                    if isinstance(content, str):
                        message["content"] = await content_filter_message(payload, content, user)
                    elif isinstance(content, list):
                        for item in content:
                            if item.get("type", "image_url") == "text":
                                item_content = item.get("text", "")
                                item["text"] = await content_filter_message(payload, item_content, user)
                    break
